c
p:文字列の長さがK以下ということは、答えになりうるsubstrの長さもK以下。
（短いほうが辞書順先なので。a<ab<abc<abcd的な。）
よって全部列挙O(NK)してsortO(NKlogNK)しても間に合う。

d
(1,2), (2,3)が来たら123間は任意だよなあということを考えると、uftで持てる
iとp[i]が同一成分に入っていればよい

e 600
1を左端に寄せ、……という進行をすればよい
（いらないものを右にどけていく作業を考えてみると、本質的にこれと同じになる）
あとは寄せるやつをどう選ぶかだが、これ貪欲で選ぶのがいい気がするなあ
↑全然違った、そんな単純な貪欲なわけないか

p:最終状態を固定すると、最小操作回数は転倒数
ボールxを固定したときのxから見た転倒数fxとする。f=Σfx。
p:最終状態をdpで左から固定していく
dp[i][j] := 黒i、白j置いた仮最終状態での、これまで置いたボールxにおけるΣfxの最小値
dp[0][0] = 0
dp[i][j] = min(dp[i-1][j] + cost[b][i][j], dp[i][j-1] + cost[w][i][j])
(cost[c][i][j]はcをi+j番目に置いたときそのボールにおける転倒数)
dpのループでN^2なのでcostを出すときのオーダーを抑えたい
p:下処理にN^2かけられるので、「左からi個の中にあるj以下のc色のボールの個数」を数えておくことによりいける。
（中断）

f 800
