ABC104
https://atcoder.jp/contests/abc104

D - We Love ABC
制約を見るとO(N^2)は無理なのでO(N)とかになる。
そうすると「端から見ていけばいいのか？」となり、dpに行き当たる。（本当か？）
dp[i][0] := i-1番目までの何も取らないパターン数
dp[i][1] := i-1番目までのAだけ取るパターン数
dp[i][2] := i-1番目までのABを取るパターン数
dp[i][3] := i-1番目までのABCを取るパターン数
とするといけそう。

実際これでいけて、
dp[0][0] = 1, dp[0][j] = 0
when S[i] == A
  dp[i+1][j] += dp[i][j]
  dp[i+1][1] += dp[i][0]
B,Cも似たようなもの
when S[i] == ?
  dp[i+1][j] += 3*dp[i][j]
  dp[i+1][j] += dp[i][j-1]
というようにi昇順で処理していける。

解説dpでは[i][j]までいった時点での正常終了するパターン数をi逆順にやっているみたいだが、こうする動機はよくわからない。（まあ上と逆向きなだけで本質は同じ）

所感

d 400
位置に対してABCを数えていく方がよさそう
Bを固定していくと、
左：Aの数*(3^?の数) + ?の数*(3^(?の数-1))
右：同上
で掛ければ出るな
え、これそのまま足していけば終わりでは
↑ダメでした

p:左から見ていってdp
editorialとは違った配るdpで書いてみる
dp[i][j] := (i-1)文字目までにjまで確定なパターン数
dp[0][0] = 1, dp[0][j] = 0
when S[i+1]=A
dp[i+1][j] += dp[i][j];
dp[i+1][1] += dp[i][0];
when S[i+1]=?
dp[i+1][j] += 3*dp[i][j];
dp[i+1][j+1] += dp[i][j];
てやるといける（O(N))

editorialっぽくやる、逆順
dp[i][j] := (i-1)文字目までにjまで確定しているとき、
残りのSがABC終了できるパターン数
イメージ：[硬い部分]_ABAB ←だんだん豊かにしていく
dp[n][3] = 1
dp[n][j] = 0
dp[i][3] = ?なら 3*dp[i+1][3] 違うなら dp[i+1][3]
dp[i][2] = Cなら dp[i+1][2] + dp[i+1][3]
             ?なら 3*dp[i+1][2] + dp[i+1][3]
             違うなら dp[i+1][2]
これをi逆順にやっていけばdp[0][0]が出る
