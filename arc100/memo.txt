c
A1-1,A2-2,...とbとの絶対値と考えていい
A1,...,b,...,Anのとき、数が多い方に詰めれば絶対値は減る
最終的に、
n=2m, m~m+1にいればどこでも
n=2m+1, m+1ジャスト

d
何かを固定するんだろうなという気持ち
真ん中を固定して左右区間。
p:単純に差を最小にすれば最適！
（切り方は考えたが↑に気づかなかった、考察が甘い）
p:あと各左右区間の差が最小になる切れ目は真ん中に対し単調増加なので尺取り法で求まる

e
K<=2*10^5くらい、つまりKlogKくらいでやりたい
毎回列挙してるとK^3になって終わるので列挙しない、
つまりK1の結果をK2を求める時に使う？
↑割と違った

まず問題を整理、max(A[i]+A[j]) (i|j <= k)を求めたい
max(A[i]+A[j]) (i|j = k)が直接出れば累積maxで終わり、
しかしこれはキツいので簡略化を考えると下に行き着く（ほんとかよ）
p:max(A[i]+A[j]) (i|j ⊆　k)を求めて累積max
なぜか？これが成立するのはi|j <= k <=> i|j ⊆ t, t <= kが成立するのと同値だからである。
=>はt=i|jとすればよく成立。<=はi|j⊆tがi|j<=tを含意することより成立。以上。

で、max(A[i]+A[j]) (i|j ⊆ k)をどうやって求めるか。
i^j⊆kはi⊆kかつj⊆kなので、結局各kに対して「i⊆k下でのA[i]のmax2つリスト」があればよい。
これは逆に考えて、各iに対して「i⊆kな全kに対してmax2つリストの更新」ができればよいとも言える
p:ところでこれはゼータ変換です、何かと言うと、「sを部分集合として持つ全Tに対するf(T)の総和」
g(s) = Σ(s⊆T) f(T)
これ、集合の包含関係が推移的だということを考えると、dpで全体を組み上げていけるんですね
有名（？）なdp式があるので天下り
REP(i, N) { REP(j, 1<<N) { if (!(j&(1<<i))) { f[j] += f[j|(1<<i)]; } } }
i=0だと000<-001,010<-011みたいな配りをしている
図を書いた、これ文章で説明するの難しい概念っぽいな
無理やり部分的に言うと、a⊆bというのは「aの1がbで1で、かつaの0のうちいくつかがbで1」なのだが、
ループiは「aで0、bで1なビットの左端がi」なbの系列での総和をaに流し込んでるみたいなイメージか？
（しっくりきてない）
まあともかくこれをやるとN*2^Nで全部出ます、
とか言いつつ今回は別バージョンのゼータ変換（全ての部分集合に対するfの総和)なので、
REP(i, N) { REP(j, 1<<N) { if (j&(1<<i)) { A[j] += A[j^(1<<i)]; } } }
a^0=a, a^1=~aなのを考えると、j^(1<<i)はjのibit目(if文的に立ってる)を0にしたもの。
ループiは「aで1、bで0なビットの左端がi」なbの系列での総和をaに流し込む感じ。

f
p:カラフルで"ない"長さNの数列全てでのAを含むものの個数を数える。
カラフルかどうか気にしなければすぐ出るので、上さえ出れば引き算で終了。

長さNのカラフルでない整数列の個数を求める。
dp[i][j] := 長さi&最後j個の要素が全部違う&最後j+1個の要素に重複がある　ような数列の個数
すると、遷移は
dp[i+1][j'] =
  if (j+1 < j') then 0   * dp[i][j]
  if (j+1 = j') then K-j * dp[i][j]
  if (j+1 > j') then 1   * dp[i][j]

長さNのカラフルでない整数列全てについて、長さMの連続する部分列で、重複する値を含まないものの個数を数える。

………（保留）
