c 400
i,jを固定してk
iによりlbが、jによりubがセットされる
これは予めしゃくとり法でO(N)で求まる
各i,jに対してO(1)でkの個数が出る
各i,jを見るとN^2なので厳しそう
やはり案の定TLE

lbを使えばiに対して使えるjの範囲がすぐわかる
ということは個数もすぐ出る、iに対しての個数を貯めておける
jも累積和で各個数が出る
Σを組み替えるとこれで答えが出る

↑で正解になったが、editorialは違うことを言っていたのでそれも要約
問題を分割する
1.
A:=(i,j,k)の個数 s.t. XiからD以内にXk,i<j<k とする。
これが出せると、all - A　によって、
(i,j,k)の個数 s.t. XiとXkがD以上離れている　が出る。
2.
B:=(i,j,k)の個数 s.t. XiもXkもXjからD以内、i<j<k とする。
これをやるとall-A-Bで出る。

p:ところでこれ、left(i)とright(i)が事前にわかっていればすぐ出る。
left(i) := Xiから左D以内にあるXの個数
left(i),right(i)自体はしゃくとりでO(N)
1. Σi (right(Xi) C 2)
2. Σj (left(j)*right(j))

d 500
単純化して、1行のハンコを右にずらしていき押すパターン
これは印影の黒のインデックス配列aを持ち、
Σi MIN(M-W+1, a[i+1]-a[i])

H,Wがでかいと潰れるし小さければ計算は容易、分けるのが良いのか？
ざっくり2倍未満かどうかとかで分けれるな
両方未満なら累積和で生成して数えればいいし、両方以上なら計算ができる
片方未満でも未満の方を生成した後計算すれば良いのか？
↑これでも行けそうな気はしたが、実装がめんどいな

editorial
H,Wの大きさに対してN,Mが大したことない（ここまではわかった）
p:座標圧縮ができます（というか真ん中を1つだけと見なせる）
そうすると累積和です　おわり
