エクサウィザーズ 2019
https://atcoder.jp/contests/exawizards2019
https://img.atcoder.jp/exawizards2019/editorial.pdf

A - Regular Triangle
B - Red or Blue
自明

C - Snuke the Wizard
N体のゴーレムについてQターンシミュレーションするとO(NQ)なので間に合わない。
よってどっちかがlogに落ちたりするんだろうなと考える。あと完全シミュレートする必要はなくて、落ちるゴーレムの数だけわかればいいんだよなと考える。
これを念頭にしばらく実験してみると、実はゴーレムiが左に落ちるならゴーレムi-1以下も全部左に落ちることがわかる。なぜなら、指示の性質上、ゴーレムi-1とiは合流することはあっても入れ替わることはないからである。
よって「左に落ちる最右ゴーレムの位置i」をQlogNで求めることができ、i+1が左に落ちるゴーレムの数である。右も同様。

D - Modulo Operations
黒板のXを次々 X = X % S[i]; していく問題。
入力例2、X=82, S={22,13,11,6,5}で考える。（ソートするのはまあそうだろう）
入力例1でわかるように、別に必ず決まった値になるとかではなくて、ちゃんとmodシミュレートする必要はあるようだ。しかし、全部の順番に対してシミュレートしているとN!なので時間が足りない。

ここでしばらく実験すると、「5で一回割ったらもう残りの22とかは全く意味がない」ということに気づく。つまり、シミュレートするのは22,13,11,6,5の部分列の個数くらいでよくて、あとはその結果に落ちるものの数をかければ良い。例えば5が先頭の取り出し順の場合、結果はX%5=2で固定であり、これが残りの4つの順番4!=24個あるので2*24=48になる。ただ、これでも部分列は2^N個あってN<=200ではTLEになる。

ここで一旦TLEになるのも構わずに実装してみる。2^Nといえばbfsな感じがするし、実際それでいける。Sを降順ソートし、Ans(x, i) := 黒板にxが書かれているとき、i番目以降のみで問題を考えた時の答え　とする。すると、これはS[i]が最終結果に反映される場合とされない場合、つまりS[i]を先頭で使う場合とそれ以外の場合の和だと考えて、
Ans(x, i) = Ans(x % S[i], i+1)
            + (Ans(x, i+1) * (N-(i+1))) (残ったやつの個数分だけS[i]を入れる場所がある、11 を 6 5の先頭以外に入れる場所は2つ)
とすることができる。
これはTLEだが、bfsといえばメモ化ということでAnsをメモ化すると、0<=x<=X<=10^5, 0<=i<N<=200なのでTLEでなくなる。よって解けた。

今回はbfsを通して考察したが、落ち着いて考えれば直接dpが出てきそうな気もする。
解説では確率と期待値にしているが、これはなんかしっくりこない。うーん
