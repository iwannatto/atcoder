AGC024
https://img.atcoder.jp/agc024/editorial.pdf

A - Fairness
https://atcoder.jp/contests/agc024/tasks/agc024_a

実際に追ってみる。
A           B      C : A-B
B+C       A+C    A+B : B-A
2A+B+C A+2B+C A+B+2C : A-B
1回操作すると差が反転するように見える。
実際、1→2と2→3の操作に本質的な違いはないので、これは一般にその通りとなる。
（
もっと露骨に、差がxの時の一般型を
A+x     A B :  x
A+B A+B+x B : -x
と書けば常に反転することがわかりやすい。
）

B - Backfront
https://atcoder.jp/contests/agc024/tasks/agc024_b

まず発想として、「移動する必要がない数字の個数の（手順に対する）最大値」を求めるという気持ちになる。

ここで移動する必要がない数字がx個あったとき、そいつらがPの中でどうなっているかを考える。すると下の概念に行き着く。
「Pの中で順序を保っている、値が連続した数字の列」を部分正当列と勝手に呼ぶことにする。
（P=[2,1,3]のとき[2,3]のみが部分正当列、みたいな）
この部分正当列が必要条件である。

さらに、部分正当列を見つけさえすれば割と自明に操作を構成できることもわかる。

よって部分正当列の長さの最大値を求めればよい。
各数字pに対して「p+1がどこにあるか」がすぐに分かれば、pとp+1のインデックスを比べることで部分正当列が続いているかどうかがすぐに分かるので、この情報を元にO(N)で答えが出る。
これは、REP(i, N) { Q[P[i]] = i; }をすることで各数字pのインデックスがわかることになり、このQを前から見ていけば連続しているかどうかが判断できるので、これによりO(N)が実現できる。

なお、提出コードでは下のメモにあるようなアルゴリズムでやっていて無駄が多い（というかよくわからない）感じになっている。


b 500
i番目を固定してそれ以外を動かすとして良い
i番目から、「きれいに逆順に並んでいる数」「きれいに正順に並んでいる数」だけ省略できる
よってこれを数えられればn-1-a-b

逆引きハッシュみたいなのを作るのかな
