c
明らかに全部1にする話である。
全被覆する操作を考えれば順番を適切に選べばいいので、
全被覆操作必要数を数える

d
まず比について考察
1 1
2 1
...
9 1
10 10
11 11/2=5.5
12 12/3=4
13 13/4=3.25
...
19 19/10=1.9
20 10
...
29 29/11=2.6...
...
99 99/18=5.5
...
109 109/10=10.9
119 119/11=10.81...
...
199 199/19=2.01

10の位以上を固定して1の位増やしていくと減るな（それはそう）
これによって1の位は9に固定される
1,2,...,9,19,199,1999...っぽい（わからんけど）
↑全然違った

f(N) := min(n | n>=Nにおいてn/S(n)の最小を与える)
がわかれば順次更新で余裕
（つまり、任意Nに対して以上最小が出るのかという話）

まずn/S(n)のn>=Nでの最小値の存在証明ができるのでしておく
p:10^d-1<=n<=10^dのとき、10^d-1/9dが最小となり、これはdを大きくすると大きくなるので、
無限に小さくなり続けるということはない（あるところでN/S(N)を超える）

で、具体的にどうやるか
下の方は9っぽいよなあという気持ちを得ている
どこかから下を9で揃えるっぽい、どこから？

p:「上から数えてNと初めて異なる桁」を10^dとして、10^d以下の桁。
理由、まず10^d-1以下の桁について考える。
p:N=???270,x=???488とかに対し、y=???399を出すと、n/S(n)に関してyは値は小さいが分母は以上だよねということで絶対小さくなる(※ここたぶんeditorial間違ってて、d+1でなくd)

次に10^dの桁について考える。
p:ここで最適x=???(2+a)99としてy=???299とおいてみる。最適なので、y/S(y)>x/S(x)のはず。
y/S(y)>y+100a/S(y)+a
yS(y)+ya>yS(y)+100aS(y)
y>100S(y)
p:さらに、aを1増やした時の大小関係を探る、「aを1増やすと小さくなるというのは本当か」
y+100a+100/S(y)+a+1 <? y+100a/S(y)+a
(y+100a)(S(y)+a)+100(S(y)+a) <? (y+100a)(S(y)+a)+y+100a
100S(y) <? y
これが上によりtrueになる。
よってaは増やせるだけ増やしたほうがいい、つまり(2+a)=9

dに関してはlog10N+1まで考えればよく、十分少なく絞れているので、fが実装できる。

e 700
保留

f 1200
保留
