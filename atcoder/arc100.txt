ARC100
https://atcoder.jp/contests/arc100/

C - Linear Approximation
右肩上がり直線y = x と ばらばらな点A[i]との差を最小化する問題。
まず重要な気付きとして、「B[i] = A[i] - (i+1) を考えれば、ΣB[i]-bを最小化するだけでよくなる」というのがある。
（つまり右肩上がりではなく横一線の直線に帰着できる）

この状態で考える。とりあえずy=0のときにどっちに動かせばいいか考えると、点の数が多い方に動かせばよい。
これで考えていくと、結局bがBの中央値に等しければよさそうとわかる。
正確には、|B|=2n+1なら普通に中央値であるn+1番目の要素b=B[n]でよくて、
|B|=2nならn番目の要素以上n+1番目の要素以下であればなんでもいいのでB[n-1]<=b<=B[n]であればよい。
まとめると、|B|=NのときB[N/2]でokということになる。
これで解けた。

D - Equal Cut
数列を4つに分けてなるべく近い値にする問題。

まず重要な思い出し事項として、「予め累積和を求めておけば区間和はO(1)で求まる」というのがある。
じゃあO(N)くらいの走査はできるな、ということを念頭に置いてもう一度問題を見ると、「真ん中の区切りで全探索すればいいのでは？」という直感が出てくる。
すると、「真ん中で区切ったとき、各左右に対してベストな区切りがすぐわかるか」という問題になる。

まずベストな区切りについて考える。RとSが固定されていて、PかQが最小値になりそう、というシチュエーションを考えてみる。
すると、PとQの和が一定であるので、PとQの差を最小にすれば最小値が一番大きくなるということがわかる。
さらにもう少し考えると、「PとQの差を最小にする」というのは他のシチュエーションでも最善手であることがわかる。

あとはこれが一瞬でできるかという話になる。
個々の区切りに対して考えると、にぶたんをすればよさそうという感覚になる。
多分これでもいいのだが、実はこの問題では尺取り法が使えるのでこれでもできるし、そっちのほうが楽である。
（QRの区切りの位置が右に動いたとき、PQの区切りの位置は右に動くかそのまましかない。よって尺取り法が使える。）
これで解けた。

所感

c
A1-1,A2-2,...とbとの絶対値と考えていい
A1,...,b,...,Anのとき、数が多い方に詰めれば絶対値は減る
最終的に、
n=2m, m~m+1にいればどこでも
n=2m+1, m+1ジャスト

d
何かを固定するんだろうなという気持ち
真ん中を固定して左右区間。
p:単純に差を最小にすれば最適！
（切り方は考えたが↑に気づかなかった、考察が甘い）
p:あと各左右区間の差が最小になる切れ目は真ん中に対し単調増加なので尺取り法で求まる

e
K<=2*10^5くらい、つまりKlogKくらいでやりたい
毎回列挙してるとK^3になって終わるので列挙しない、
つまりK1の結果をK2を求める時に使う？
↑割と違った

まず問題を整理、max(A[i]+A[j]) (i|j <= k)を求めたい
max(A[i]+A[j]) (i|j = k)が直接出れば累積maxで終わり、
しかしこれはキツいので簡略化を考えると下に行き着く（ほんとかよ）
p:max(A[i]+A[j]) (i|j ⊆　k)を求めて累積max
なぜか？これが成立するのはi|j <= k <=> i|j ⊆ t, t <= kが成立するのと同値だからである。
=>はt=i|jとすればよく成立。<=はi|j⊆tがi|j<=tを含意することより成立。以上。

で、max(A[i]+A[j]) (i|j ⊆ k)をどうやって求めるか。
i^j⊆kはi⊆kかつj⊆kなので、結局各kに対して「i⊆k下でのA[i]のmax2つリスト」があればよい。
これは逆に考えて、各iに対して「i⊆kな全kに対してmax2つリストの更新」ができればよいとも言える
p:ところでこれはゼータ変換です、何かと言うと、「sを部分集合として持つ全Tに対するf(T)の総和」
g(s) = Σ(s⊆T) f(T)
これ、集合の包含関係が推移的だということを考えると、dpで全体を組み上げていけるんですね
有名（？）なdp式があるので天下り
REP(i, N) { REP(j, 1<<N) { if (!(j&(1<<i))) { f[j] += f[j|(1<<i)]; } } }
i=0だと000<-001,010<-011みたいな配りをしている
図を書いた、これ文章で説明するの難しい概念っぽいな
無理やり部分的に言うと、a⊆bというのは「aの1がbで1で、かつaの0のうちいくつかがbで1」なのだが、
ループiは「aで0、bで1なビットの左端がi」なbの系列での総和をaに流し込んでるみたいなイメージか？
（しっくりきてない）
まあともかくこれをやるとN*2^Nで全部出ます、
とか言いつつ今回は別バージョンのゼータ変換（全ての部分集合に対するfの総和)なので、
REP(i, N) { REP(j, 1<<N) { if (j&(1<<i)) { A[j] += A[j^(1<<i)]; } } }
a^0=a, a^1=~aなのを考えると、j^(1<<i)はjのibit目(if文的に立ってる)を0にしたもの。
ループiは「aで1、bで0なビットの左端がi」なbの系列での総和をaに流し込む感じ。

f 1100
p:カラフルで"ない"長さNの数列全てでのAを含むものの個数を数える。
カラフルかどうか気にしなければすぐ出るので、上さえ出れば引き算で終了。

長さNのカラフルでない整数列の個数を求める。
dp[i][j] := 長さi&最後j個の要素が全部違う&最後j+1個の要素に重複がある　ような数列の個数
すると、遷移は
dp[i+1][j'] =
  if (j+1 < j') then 0   * dp[i][j]
  if (j+1 = j') then K-j * dp[i][j]
  if (j+1 > j') then 1   * dp[i][j]

長さNのカラフルでない整数列全てについて、長さMの連続する部分列で、重複する値を含まないものの個数を数える。

………（保留）
