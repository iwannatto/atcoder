AGC027
https://img.atcoder.jp/agc027/editorial.pdf

A - Candy Distribution Again
https://atcoder.jp/contests/agc027/tasks/agc027_a

昇順ソートして順に配っていけばよい。
全員に配って丁度尽きる＝N
全員に配って余る＝N-1
全員に配ってないけどもう配れない＝今まで配った人数
というロジックを実現すればよい。（コードでは表現が微妙に違う。）

C - ABland Yard

任意の文字列が作れるとき、ABの両方に行ける頂点以外を消しても任意の文字列が作れる。
（
Aにしか行けない頂点Kが必須のとき、ある文字列SにおいてS[K]=="A"となるが、そうするとS[0:K+1]+"B"が作れないので矛盾。よってそのような頂点は必須ではない。
）

これの対偶より、ABの両方に行ける頂点以外を消した結果任意の文字列が作れなくなってしまったら、そのグラフでは任意の文字列が作れなかったことになる。また、全件の判定は頂点が残るかどうかだけ見ればよい。
よってこれを実装すればよい。
Bfs(i) := 頂点iを消せるなら消し、そこから隣接するやつも消せるなら全部消す
という関数を作り、REP(i, N) { Bfs(i); }
とやればこれは実現できる。
（
最初から消えるやつは全部走査される。
他のやつが消えた結果消えるやつは、必ずその隣接するやつが消えるタイミングで消せるようになるため、消した瞬間に隣接するやつを全部調べれば漏れがない。
）
これを実現する上でいちいち辺を消す必要はなく、
あらかじめ各頂点が隣接するA/Bの頂点数カウントを持っておき、
頂点を消すときは消えた頂点の隣接する頂点の頂点数カウントを減らせばよい。

再帰関数で実現したが、トポロジカルソート風にキューやスタックを使うなどしてもよい。（本質的には同じ集合の範囲を走査するので同じことであるが。）

agc027
a sortして貪欲的な
b 何一つわからない
c ちょっと考えると結局ダメな頂点を消していけばいいということがわかり、各頂点に隣接abの数を覚えさせてbfsで消していくと間に合う　900もない
