ABC116
https://img.atcoder.jp/abc116/editorial.pdf

D - Various Sushi
https://atcoder.jp/contests/abc116/tasks/abc116_d

まずおいしさ上位順に取るとどうなるかを考える。
すると当然ながら、他のどの組み合わせもこれよりおいしさ基礎ポイントは高くならない。
よって、他の組み合わせがこれより高くなるとしたら、それは種類数が増えたことによるものである。

おいしさ上位順に取ったときにx種類だったとする。
このとき、x+1種類でかつおいしさが最大のものは、「おいしさ上位順の中から”除いても種類が減らない中でおいしさ最小”のものを取り除き、代わりに種類を増やすものの中でおいしさ最大のものを足す」ことで求まる。
x+2以降に対しても、同様のことをすれば求まる。
よって、この操作さえできれば、x以上の種類数でのポイントを全部求めてその最大値を取ることで答えが出る。

上の操作の実装を考える。
おいしさ上位順にソートした時を考える。
すると、どの段階でも、除かれるのは最初のK個に入っていたもの、すなわちインデックスがi<Kであるものである。なぜなら、種類数増加のためにあとから足したやつは1種類につき1個しかなくて取り除けないからである。
さらにおいしさ順ソートされているので、iを逆順に見ていき、一番最初に行き当たった「除いても種類が減らないもの」を除く、というのをグローバルなiのもと繰り返せば除く操作が実現できる。
しかもおいしさ順ソートされているので、追加するためのものも、インデックスj>=Kを増やしながら順番に見ていき、今までにない種類のものだったら追加、というのをグローバルなjのもとやればわかる。
種類の保存にはHashを使うようにすればこれは普通に実現できる。

解説にpriorityQueueと書いてあるのは全く意味がわからない。普通に必要ないのではと思ってしまう。
