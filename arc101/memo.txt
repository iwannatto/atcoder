ARC101
https://atcoder.jp/contests/arc101

C - Candles
連続するK本を取ればいいし、N<=10^5なのでK本の取り方に関して全探索ができる。
端a,bに対して、MIN(ABS(a), ABS(b)) + (b - a)が移動時間なので、これで全探索ができる。
提出ではもう少しごちゃごちゃしてしまっているが、必要はない。

D - Median of Medians
「中央値といえばにぶたん」という常識があり、「b中にx以上の要素が(M+1)/2個以上あるかどうか」がO(hoge)でわかればO(hoge*log(値の範囲))という短い時間で中央値を特定できる。
よって、「連続部分列の中央値m_l,r全体にx以上の要素が(n+1)/2個以上あるかどうか」がO(NlogN)くらいでわかればありがたい。
ただし、n = (l, r)の選び方の全体 = N(N-1)/2 + N
これは「l,rであって、a_l...a_rのうち中央値がx以上であるものが(n+1)/2個以上あるかどうか」となる。

ここから答えに辿り着くまでに知っておくべきことは「転倒数」である。
転倒数とはi<jかつa_i>a_jであるような(i,j)の個数のことで、重要なのはこれをNlogNで求めるアルゴリズムがあるということである。
この問題はこれに帰着させることができる。

帰着させる方法は発想っぽくて、累積和を使うことで帰着させることができる。
aをx以上なら+1,そうでないなら-1に置き換える。
すると、「l,rであって、a_l+...+a_r>=0であるものが(n+1)/2個以上あるかどうか」と言い換えられる。
ここで連続部分列の和は累積和Sで簡単に出るので、「l,rであって(lに0を許し、l=rを許さない)、S_r-S_l>=0であるものが(n+1)/2個以上あるかどうか」となる。
そうするとl<rかつS_l<=S_rを求める問題となり、転倒数を出す要領で答えが出せる。

転倒数については正直あまり馴染みがなかったので、転倒数アルゴリズムについても書いておく。
転倒数というか、l<rかつS_l<=S_rなl,rの個数をsumとして直接求める問題として考える。（転倒数が欲しければここからすぐわかる。）

これはSの値に対応する要素を持つBIT bを使うことによって求めることができる。
アイデアとしては、BITに「今までb[i]以下がいくつあったか」を持たせる、というものである。
わかりやすさのため、Sの値は正であったとする。

b.Add(S[r], 1)
FOR(r, 1, N) {
  sum += b.Sum(S[r]);
  b.Add(S[r], 1);
}

sum+=の部分がポイントで、あるrを見ている時点でb.Sum(S[r])を見るとこれがS[l]<=S[r]であるようなlの個数になっている。
よってこうすることで転倒数（的なやつ）が求まることになる。提出ではS>=0のためにもうちょい前処理的なのがあるがやっていることはこれである。


所感

d 700
何番目かはわかるな
(l,r)の取り方がN+(N-1)+...+1なので計N(N+1)/2要素、
よって最終的な数列のN(N+1)/4+1番目(1-indexed)の要素が答え。

t[i][j] := i<=j間の中央値　としたとき、
t[i][j+1] =
↑ちがう

p:値でにぶたんをする
中央値xは「b中にx以上の要素が(M+1)/2個以上含まれる」最大のx
これを用いて問題を言い換えられる
xとの大小で-1,1にすると、a[l,r]の要素の総和に帰着できる。
(1<=l<=r<=N)
p:a[l,r]の要素の総和は累積和。
S[r]-S[l-1]>=0 <=> カウント1　なので、
(l,r)のうちS[l]<=S[r]を満たすものは何通りか(0<=l<r<=N)となる。
p:これは転倒数を求めればよく、典型。
Sの値の範囲は-N~Nなので一律Nを足して0~2Nにすればbitでいける。
