AGC020
https://img.atcoder.jp/agc020/editorial.pdf

A - Move and Win
https://atcoder.jp/contests/agc020/tasks/agc020_a

D=B-Aの偶奇が常に変わらない。
AliceのターンにD=1だと引かざるを得なくてAlice負ける。D=2だとAlice勝てる。
上2つより、初期状態のDの偶奇で単に場合分けすればよい。

B - Ice Rink Game
https://atcoder.jp/contests/agc020/tasks/agc020_b

最小、最大をLi, Riとする。LK=RK=2がわかっている。
まず、普通に遡ることを考える。つまり、Li, Ri, AiからLi-1, Ri-1を出せるか考えてみる。

まず、遡ってはきたけどLi, Riが整合していないことがありうる。Aiの直後に生き残っているのはAiの倍数人なはずなので、[Li, Ri]にAiの倍数が入っていないとそもそもダメである。
整合している場合、[Li, Ri]内にあるAiの倍数の最小、最大をXi, Yiとすると、
Li-1 = Xi
Ri-1 = Yi+(Ai - 1)
がわかる。
Xi = Ceil(Li / Ai) * Ai = (Li + Ai - 1) / Ai
Yi = Floor(Ri / Ai) * Ai = (Ri / Ai) * Ai
なので、結局普通にL0, R0まで遡ればよい。

また、今回の問題では計算量が減るわけではない（というか増える）が、二分探索でも解ける。
Aiで人数を減らす操作をf_Aiとする。
fは広義単調増加であるので、全fの合成であるgも広義単調増加である。
よって、Nの範囲が絞れていれば、g(N)>=2な最小のNおよびg(N)<=2な最大のNを求めることができ、これらがそのまま答えになる。（前者が後者を上回る場合は-1となる。）
Nは例えば2+K*MAX(Ai)で上から抑えられるので、これで二分探索ができる。

C - Median Sum
https://atcoder.jp/contests/agc020/tasks/agc020_c

一旦、空部分列S0も部分列として認めることにする。
任意の部分列Pに対し、残った要素をすべて取った部分列Qを考えることができる。
どの(P,Q)に関してもΣP+ΣQ=ΣAが成り立つので、ΣPとΣQのうち、片方はΣA/2以上であり、片方はΣA/2以下となる。
よってΣA/2以上の領域とΣA/2以下の領域にあるものの個数は同じなので、これだけで考えれば中央値はΣA/2である。
ところが実際にはS0が部分列として認められないため、正方向に一つずれる。
すると、要素の和が「ΣA/2以上になるものの中で最小」であるような部分列の和が答えとなることがわかる。

計算には
dp(i,j):=最初のi項を取ると和をjにすることができる
を使う。これは2000^3かかるので怪しい感じはするが、実際にはbitsetで64倍高速化することができるので十分間に合う。
