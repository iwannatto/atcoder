ABC106
https://atcoder.jp/contests/abc106
https://img.atcoder.jp/abc106/editorial.pdf

A - Garden
自明

B - 105
普通に二重ループで全部見ればよい。
ちなみに、n=p^7,p^3*q,p*q*rであることから考えるとN<=200の範囲ではn=105, 135, 165, 189, 195だと特定できる。でもコンテストでやる必要はないかな……。

C - To Infinity
2以上の文字が無限個になるので最初にでてきた2以上の文字を答えればよい。ただし、最初に1がK個並んでいた場合には1。
実装上は、K文字まで前から見て1以外が出てきたら打ち切る、なかったら1、とすれば楽。

D - AtCoder Express 2
ポイントは、Nがかなり小さいことである。よって、クエリ毎にO(N)くらいかかっても問題はない。
で、O(N)でやるには何がほしいかを問題設定からしばらく考えてみると、「ちょうどiから始まり、j以内に終わる電車の個数」がわかればよさそうとわかる。これをt[i][j]とする。
これの下準備を考えると、L[i],R[i]は t[L[i]][j] (j >= R[i]) を1増やす効果があるので、累積和を使えばO(M+N^2)で下準備ができる。よってこれでよい。

解説では、累積和を利用した表ではなく、累積和そのものを持っている。
c[i][j] := i以内から始まり、j以内に終わる電車の個数　とする。
すると、t[i][j]の参照==c[j][j]-c[i-1][j]となるので、同じことが実現できる。
二次元座標として見るという発想をするとこうなるっぽい。
この問題では必ずしも必要ではないが、こういう風に区間みたいな2点で特徴づけられるものを座標として見なすという考え方はどこかで使えるかもしれない。

abc106
a はい
b 全部見た
c 1がK個以上並んでるときを見落とすと悲しい
d t[i][j]:=「丁度iから始まり、j以内に終わる電車の個数」とやる
各クエリにO(N)で答えられる、Nが小さいのでこれでいい。
下準備は累積和でO(M+N^2)
あとこれ各区間を2次元平面上の1点とみなすと見通しが良くなる
