全国統一プログラミング王決定戦予選/NIKKEI Programming
Contest 2019
https://img.atcoder.jp/nikkei2019-qual/editorial.pdf

C - Different Strokes
https://atcoder.jp/contests/nikkei2019-qual/tasks/nikkei2019_qual_c

実験したりとかするとA+Bのでかい方から取っていくのが最善ではという直感が働く。
とりあえずN=2のとき、高橋くんは
A1 - B2 <=> A2 - B1
つまり
A1 + B1 <=> A2 + B2
に従って取るべきであるので成り立っている。
N=3のとき、
A1 + MIN(A2-B3, A3-B2)
A2 + MIN(A1-B3, A3-B1)
A3 + MIN(A1-B2, A2-B1)
を最大化するべきだが、それぞれにB1+B2+B3を足すと
A1+B1 + MIN(A2+B2, A3+B3)
A2+B2 + MIN(A1+B1, A3+B3)
A3+B3 + MIN(A1+B1, A2+B2)
を最大化すればよくなり、もうちょい考えればこのときにも成り立っているのがわかる。
わからんけどN=4以上でも成り立っていそうなので出したら通った。

もちろん上は考え方としてはよくなくて、一般のNに対しては次のようにする。
要約すると発想の転換ゲーである。
このゲームは最初は中央に料理が全部あり、各ターンにお互いがスコアを獲得していくが、これをずらして考える。
すると、「青木さんが最初から全部料理を持っていて、高橋くんが各ターン毎に攻撃して料理を奪う。青木さんは各ターン毎にディフェンスする」というゲームになる。
すると高橋君は攻撃のたびにA+Bのスコアを得、青木さんはディフェンスの際に何も得ない、となる。
よってお互いにA+Bが高い方から選んでいくのが最善とわかる。

D - Restore the Tree
https://atcoder.jp/contests/nikkei2019-qual/tasks/nikkei2019_qual_d

実験していると次に気づく。
aからbへの（共通辺のない）経路が2通りあるとき、一つはaとbを直接つなぐものであり、もう片方が元の木の辺である。

もうひとつ気づくこととして、
元々根だった頂点に辺が新しく入ってくることはないし、元々根じゃなかった頂点にはどっかしらから辺が入ってきている
ことにより、グラフから元の木の根がすぐにわかる。

以上より、各頂点に対して
* 親が1つならそれが元々の親
* 親が2つ以上あるなら根から来た時の累計距離を各親に対して計算し、その距離が一番長いやつが元々の親
という処理により、根から来た時の累計距離がわかるうえに元々の親が確定する。
これをメモ化再帰で計算すればよい。
（
このグラフは木と流れに沿う辺しかないので閉路とかがなく、単純に根まで辿るだけでバグることなく距離を計算できる。
）

なお、解説で示されている通り、実はこれはもっと一般化できる。
DAG(Directed Asyclic Graph) := 閉路のないグラフ
という言葉があり、この問のグラフは当然DAGである。そして、
DAG ⇔ トポロジカルソートができる
であるため、このグラフはトポロジカルソートできる。O(N+M)。
そして、トポロジカルソートしたとき、
bの真の親はa→bと直接つながっているような最大のaである
ということがいえる。
これを使うと、ソートの小さい頂点から出ている辺で指す先の親を更新していく、というようなプログラムで答えが出せるはずである。
