全国統一プログラミング王決定戦予選/NIKKEI Programming
Contest 2019
https://img.atcoder.jp/nikkei2019-qual/editorial.pdf

D - Restore the Tree
https://atcoder.jp/contests/nikkei2019-qual/tasks/nikkei2019_qual_d

実験していると次に気づく。
aからbへの（共通辺のない）経路が2通りあるとき、一つはaとbを直接つなぐものであり、もう片方が元の木の辺である。

もうひとつ気づくこととして、
元々根だった頂点に辺が新しく入ってくることはないし、元々根じゃなかった頂点にはどっかしらから辺が入ってきている
ことにより、グラフから元の木の根がすぐにわかる。

以上より、各頂点に対して
* 親が1つならそれが元々の親
* 親が2つ以上あるなら根から来た時の累計距離を各親に対して計算し、その距離が一番長いやつが元々の親
という処理により、根から来た時の累計距離がわかるうえに元々の親が確定する。
これをメモ化再帰で計算すればよい。
（
このグラフは木と流れに沿う辺しかないので閉路とかがなく、単純に根まで辿るだけでバグることなく距離を計算できる。
）

なお、解説で示されている通り、実はこれはもっと一般化できる。
DAG(Directed Asyclic Graph) := 閉路のないグラフ
という言葉があり、この問のグラフは当然DAGである。そして、
DAG ⇔ トポロジカルソートができる
であるため、このグラフはトポロジカルソートできる。O(N+M)。
そして、トポロジカルソートしたとき、
bの真の親はa→bと直接つながっているような最大のaである
ということがいえる。
これを使うと、ソートの小さい頂点から出ている辺で指す先の親を更新していく、というようなプログラムで答えが出せるはずである。
