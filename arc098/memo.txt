c
W=西＝左、E=東＝右。
各位置iについて、0~i-1までにいる西向きの人数 + i+1~n-1までの東向きの人数　の最小値。
累積和。

d
条件について
全部の数字を縦に並べるとイメージしやすいのだが、結局は繰り上がりがあるとダメという話になる。
ということは、「数字を追加すればするほど条件がキツくなる」こともわかる。これが重要。
個数について
l,rで条件を満たしてるなら、l,r-1みたいに、もっと短い範囲のやつも全部条件を満たしてることになる。
よって、「lに対応する1番大きいr」を考えていくと、尺取り法で求まる。

e
p:XとYが2つ動くとつらいので片方を固定したい。
Yを固定し、「最小値がYになるという制約下でXを最小化する」という問題であると考える。

p:制約的に、Y-1以下の値はダメ。ダメなやつで切ると部分列ができる。
各部分列について、
部分列の大きさmとすると、除去操作をm-K+1回できるので、小さい方からm-K+1個は除去候補。
全部分列の除去候補を昇順sort(NlogN)して小さい方からQ番目がmin(X)。
これを各XにやるとN^2logN。

f
p:操作を逆から見ると単純化できる。
次のように思える。
適当な頂点sからスタート、任意円持っている。
下のどっちかを、全頂点でお金をもらったことになるまで繰り返す。
今いる頂点をvとして、
1. Bv円もらう。（頂点毎に一度だけ。）
2. 隣接する好きな頂点に移動する。（Av円以上持っている時だけ可能。）
最終頂点tにおいてAt円以上持っていたらゲームクリア。

これは、
新頂点に行った瞬間にBv円得るのが最善手
Av-Bv以上円持ってないと新頂点に移動しちゃいけない
一度訪れた頂点間は自由に行き来できる
ということを考えて、更に簡略化できる。
Cv:=max(Av-Bv,0)として、　←max取る必要あるのか？所持金>=0が保証されていないならあるか。
適当な頂点sからスタート、Cs円以上持っている。
下を全頂点訪問するまで繰り返す。
今まで訪れた頂点と隣接する新頂点vを選び、Bv円を得る。（Cv円以上持っている時だけ可能。）
全ての頂点を訪れることができればゲームクリア。
ゲームクリア時の所持金として考えられる最小の金額がans。
これは明らかにCvが最小なvを選び続けるのが最適。

ここまでわかったところで、
p:Cvが最大の頂点zについて、「最後にCzに行くのかなあ」という気持ちを持つ。
そこで、このCzを取り外して、「最適解がzスタートのときと、そうでないとき」で場合分け。
すると、残った連結成分をP1,...,Plとして、ゲームクリア時の所持金の最小値は、
最適解がzスタートのとき：
ans = Cz + ΣBv
最適解がPiスタートのとき(Pi内クリア時最小所持金をQiとする)：
ans = max(Qi,Cz) + ΣBv(Piじゃないゾーン)
ここまでで分割による多項式解法が得られそうなのがわかる。

ところでグラフをちゃんと分割するのは結構大変な処理っぽい。そこで、
p:グラフができていく過程を逆から考えてみる。
すると、Cvの小さい頂点でできるだけ大きい連結成分を作っていく　みたいな気持ちが得られる。
ここで、
p:各辺(u,v)のコストをmax(Cu,Cv)と考える。
すると、これはクラスカル法で組み上がっていく過程と対応するのがわかる。
あとは木dpしながら組み上げていけばいい。

クラスカルのソートNlogNが全体の計算量になる。
